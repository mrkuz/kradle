package net.bnb1.kradle.features.jvm

import Catalog
import net.bnb1.kradle.features.EmptyProperties
import net.bnb1.kradle.features.FeatureDslImpl
import net.bnb1.kradle.features.Properties
import net.bnb1.kradle.property
import org.gradle.api.Project

class JvmProperties(project: Project) : Properties(project) {

    val targetJvm = property(factory.property(Catalog.Versions.jvm))

    val kotlin = FeatureDslImpl(KotlinFeature(), KotlinProperties(project))
        .setParent(JvmFeatureSet::class)
        .addBlueprint(JavaBlueprint(project))
        .addBlueprint(KotlinBlueprint(project))
        .addBlueprint(AllOpenBlueprint(project))
        .register(project)
        .asInterface()
    val application = FeatureDslImpl(ApplicationFeature(), ApplicationProperties(project))
        .setParent(JvmFeatureSet::class)
        .addBlueprint(ApplicationBlueprint(project))
        .register(project)
        .asInterface()
    val library = FeatureDslImpl(LibraryFeature(), EmptyProperties(project))
        .setParent(JvmFeatureSet::class)
        .addBlueprint(LibraryBlueprint(project))
        .addBlueprint(MavenPublishBlueprint(project))
        .register(project)
        .asInterface()
    val dependencyUpdates = FeatureDslImpl(DependencyUpdatesFeature(), EmptyProperties(project))
        .setParent(JvmFeatureSet::class)
        .addBlueprint(DependencyUpdatesBlueprint(project))
        .register(project)
        .asInterface()
    val vulnerabilityScan = FeatureDslImpl(VulnerabilityScanFeature(), EmptyProperties(project))
        .setParent(JvmFeatureSet::class)
        .addBlueprint(OwaspDependencyCheckBlueprint(project))
        .register(project)
        .asInterface()
    val lint = FeatureDslImpl(LintFeature(), EmptyProperties(project))
        .setParent(JvmFeatureSet::class)
        // Make sure test an benchmark source sets are available
        .after(TestFeature::class, BenchmarkFeature::class)
        .addBlueprint(LintBlueprint(project))
        .register(project)
        .asInterface()
    val codeAnalysis = FeatureDslImpl(CodeAnalysisFeature(), EmptyProperties(project))
        .setParent(JvmFeatureSet::class)
        .after(TestFeature::class, BenchmarkFeature::class)
        .addBlueprint(CodeAnalysisBlueprint(project))
        .register(project)
        .asInterface()
    val test = FeatureDslImpl(TestFeature(), TestProperties(project))
        .setParent(JvmFeatureSet::class)
        .addBlueprint(TestBlueprint(project))
        .addBlueprint(JacocoBlueprint(project))
        .register(project)
        .asInterface()
    val benchmark = FeatureDslImpl(BenchmarkFeature(), BenchmarkProperties(project))
        .setParent(JvmFeatureSet::class)
        .addBlueprint(AllOpenBlueprint(project))
        .addBlueprint(BenchmarksBlueprint(project))
        .register(project)
        .asInterface()

    @SuppressWarnings("VariableNaming")
    val `package` = FeatureDslImpl(PackageFeature(), PackageProperties(project))
        .setParent(JvmFeatureSet::class)
        .addBlueprint(PackageBlueprint(project))
        .addBlueprint(ShadowBlueprint(project))
        .register(project)
        .asInterface()
    val packaging = `package`
    val documentation = FeatureDslImpl(DocumentationFeature(), EmptyProperties(project))
        .setParent(JvmFeatureSet::class)
        .addBlueprint(DokkaBlueprint(project))
        .register(project)
        .asInterface()
    val docker = FeatureDslImpl(DockerFeature(), DockerProperties(project))
        .setParent(JvmFeatureSet::class)
        .addBlueprint(JibBlueprint(project))
        .register(project)
        .asInterface()
}
